"""
Azure Cognitive Search vector operations client wrapper.

This module provides a simplified Python client for Azure Cognitive Search
vector index operations. It wraps the Azure Search REST API for document
upserts and vector similarity queries.

Current Implementation:
    - REST API calls using requests library (simple, synchronous)
    - Basic authentication with API key
    - JSON request/response handling

Production Recommendations:
    Replace with official Azure SDK:
    
    from azure.search.documents import SearchClient
    from azure.core.credentials import AzureKeyCredential
    
    client = SearchClient(
        endpoint=endpoint,
        index_name=index_name,
        credential=AzureKeyCredential(api_key)
    )
    
    # Upload documents
    client.upload_documents(documents=[...])
    
    # Vector search
    results = client.search(
        search_text="",
        vector={"value": query_vector, "fields": "embedding"},
        top=5
    )

Use Cases:
    1. Chat History Search: Find similar past conversations
    2. Resource Discovery: Semantic search over cloud resources
    3. Recommendation Context: Find relevant optimization insights

Vector Embeddings:
    - Generated by: OpenAI text-embedding-3-small (1536 dimensions)
    - Similarity Metric: Cosine similarity
    - Index Algorithm: HNSW (Hierarchical Navigable Small World)

Configuration:
    AZURE_SEARCH_ENDPOINT: Azure Cognitive Search endpoint URL
    AZURE_SEARCH_KEY: Admin API key from Azure portal

Author: Cloud Optimizer Team
Version: 2.0.0 (Phase 2 - Basic Implementation)
Last Modified: 2026-01-25
TODO: Replace with official Azure SDK for production
"""

import os
import requests
from app.config import settings

class AzureVectorClient:
    """
    Simple wrapper for Azure Cognitive Search vector operations.
    
    Provides basic document upsert and vector search functionality using
    the Azure Search REST API. Uses API key authentication.
    
    Attributes:
        endpoint (str): Azure Search service endpoint URL
        key (str): Admin API key for authentication
        index_name (str): Name of the search index to operate on
    
    API Version:
        Uses 2024-07-01-preview (required for vector search features)
    
    Index Schema Requirements:
        The target index must have fields:
        - id (Edm.String): Document unique identifier
        - vector (Collection(Edm.Single)): Embedding vector (1536 dimensions)
        - metadata (Edm.String): JSON string with document metadata
    
    Example Index Definition:
        {
            "name": "vectors",
            "fields": [
                {"name": "id", "type": "Edm.String", "key": true},
                {"name": "vector", "type": "Collection(Edm.Single)", "dimensions": 1536},
                {"name": "metadata", "type": "Edm.String"}
            ],
            "vectorSearch": {
                "algorithms": [
                    {"name": "hnsw", "kind": "hnsw"}
                ]
            }
        }
    """
    
    def __init__(self, endpoint: str = None, key: str = None, index_name: str = "vectors"):
        """
        Initialize Azure Search client.
        
        Args:
            endpoint (str, optional): Azure Search endpoint URL.
                                     Defaults to AZURE_SEARCH_ENDPOINT from config.
            key (str, optional): Admin API key.
                                Defaults to AZURE_SEARCH_KEY from config.
            index_name (str, optional): Index name. Defaults to "vectors".
        
        Example:
            # Use configuration defaults
            client = AzureVectorClient()
            
            # Custom endpoint and key
            client = AzureVectorClient(
                endpoint="https://myservice.search.windows.net",
                key="admin-key-here",
                index_name="chat_embeddings"
            )
        """
        self.endpoint = endpoint or settings.AZURE_SEARCH_ENDPOINT
        self.key = key or settings.AZURE_SEARCH_KEY
        self.index_name = index_name

    def upsert_document(self, doc_id: str, vector: list, metadata: dict):
        """
        Upsert (insert or update) a document with vector embedding.
        
        Uploads a document to the search index with its vector embedding and
        metadata. If a document with the same ID exists, it is replaced.
        
        Args:
            doc_id (str): Unique document identifier
            vector (list): Embedding vector (1536 floats from OpenAI)
            metadata (dict): Document metadata (e.g., {"message": "...", "timestamp": "..."})
        
        Returns:
            dict: Azure Search API response containing:
                - value (list): Results per document
                    - key (str): Document ID
                    - status (bool): Success/failure
                    - statusCode (int): HTTP status code
        
        Raises:
            requests.HTTPError: If API call fails (4xx/5xx status)
        
        Example:
            from openai import OpenAI
            client_openai = OpenAI()
            
            # Generate embedding
            response = client_openai.embeddings.create(
                model="text-embedding-3-small",
                input="Hello world"
            )
            vector = response.data[0].embedding
            
            # Upsert to Azure Search
            search_client = AzureVectorClient()
            result = search_client.upsert_document(
                doc_id="msg_123",
                vector=vector,
                metadata={"message": "Hello world", "timestamp": "2026-01-25T10:00:00"}
            )
        """
        # Construct API URL for document indexing
        url = f"{self.endpoint}/indexes/{self.index_name}/docs/index?api-version=2024-07-01-preview"
        
        # Set request headers (API key authentication)
        headers = {
            "api-key": self.key,
            "Content-Type": "application/json"
        }
        
        # Build request body with upload action
        body = {
            "value": [
                {
                    "@search.action": "upload",  # Insert or replace
                    "id": doc_id,
                    "vector": vector,
                    "metadata": metadata
                }
            ]
        }
        
        # Execute API call
        r = requests.post(url, headers=headers, json=body)
        r.raise_for_status()  # Raise exception on 4xx/5xx
        return r.json()

    def query_vector(self, vector: list, top_k: int = 5):
        """
        Perform vector similarity search to find nearest neighbors.
        
        Searches the index for documents with vectors most similar to the
        query vector using cosine similarity.
        
        Args:
            vector (list): Query embedding vector (1536 floats)
            top_k (int, optional): Number of results to return. Defaults to 5.
        
        Returns:
            dict: Azure Search API response containing:
                - value (list): Top-k similar documents:
                    - id (str): Document ID
                    - @search.score (float): Similarity score (0-1)
                    - vector (list): Document's embedding vector
                    - metadata (dict): Document metadata
        
        Raises:
            requests.HTTPError: If API call fails
        
        Similarity Scoring:
            - 1.0 = Identical vectors (perfect match)
            - 0.9+ = Very similar (same topic/intent)
            - 0.7-0.9 = Moderately similar (related concepts)
            - <0.7 = Weakly similar or unrelated
        
        Example:
            # Generate query embedding
            query_text = "Show me my EC2 instances"
            response = client_openai.embeddings.create(
                model="text-embedding-3-small",
                input=query_text
            )
            query_vector = response.data[0].embedding
            
            # Search for similar past queries
            search_client = AzureVectorClient()
            results = search_client.query_vector(query_vector, top_k=3)
            
            for doc in results["value"]:
                print(f"Score: {doc['@search.score']:.3f}")
                print(f"Message: {doc['metadata']['message']}")
        """
        # Construct API URL for search
        url = f"{self.endpoint}/indexes/{self.index_name}/docs/search?api-version=2024-07-01-preview"
        
        # Set request headers
        headers = {
            "api-key": self.key,
            "Content-Type": "application/json"
        }
        
        # Build search request body with vector query
        body = {
            "vector": {
                "value": vector,  # Query embedding
                "fields": "vector"  # Field to search
            },
            "top": top_k  # Number of results
        }
        
        # Execute search API call
        r = requests.post(url, headers=headers, json=body)
        r.raise_for_status()
        return r.json()